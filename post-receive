#!/usr/bin/env perl
# Copyright (c) 2022 Ashlen <eurydice@riseup.net>

# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.

# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

# post-receive hook, see githooks(5)

# TODO: Add verbosity toggle.
# Can this be generalized?
# Can this be made more readable?

use autodie ':all';
use strict;
use warnings;

use feature 'say';

# Base modules.
use Cwd 'cwd';
use File::Basename 'fileparse';
use File::Copy qw(copy move);
use File::Find;
use File::Spec::Functions qw(catdir catfile rootdir);
use File::Temp 'tempdir';
use IO::Compress::Gzip qw(gzip $GzipError);
use IPC::Open3;

# External modules.
use IPC::System::Simple;

sub check_dependencies {
	open my $which_fh, '-|', 'which', '--', @_;

	my @dependency_checks;
	while (<$which_fh>) {
		chomp;
		push @dependency_checks, $_;
	}

	if ( scalar @_ != scalar @dependency_checks ) {
		my $count = 0;
		while (<@_>) {
			$dependency_checks[$count] // '' =~ /$_/
				or die "$_ is not installed!\n";
			$count++;
		}
	}

	# Placing this before the comparison loop masks the real error.
	close $which_fh;

	return scalar @dependency_checks;
}

my @dependencies = qw(stagit git);
check_dependencies @dependencies;

# NOTE: MUST be pushing to a bare git repository.
my $repo_location = cwd;
my $repo_name = fileparse $repo_location;
my $repo_name_no_dot_git = $repo_name =~ s/\.git\z//r;

my $home = $ENV{'HOME'} // ( getpwuid $< )[7];
my $bindir = catdir $home, qw(.local bin);
my $bin_ssg = catdir $bindir, 'ssg6';
my $bin_rssg = catdir $bindir, 'rssg';

# $owner is written to $repo_location/owner
my ( $owner, $domain_with_schema ) = qw(Ashlen https://amissing.link);
my $domain_without_schema = $domain_with_schema =~ s{\A[a-z]+://}{}r;

my $web_server_dir = catfile &rootdir, qw(var www htdocs),
	$domain_without_schema;

my ( $src_dir, $src_page ) = qw(src src.html);
my $stagit_dir = catdir $web_server_dir, $src_dir, $repo_name_no_dot_git;

my ( $website_repo_name, $sysadm_repo_name, $dotfiles_repo_name ) =
	qw(website_md sysadm dotfiles);

# The key for the repo in use is written to $repo_location/description
my %repo_descriptions = (
	$website_repo_name => "Source for $domain_without_schema",
	$sysadm_repo_name => 'System Administration Tools',
	$dotfiles_repo_name => 'OpenBSD configuration files',
	'learning_perl_exercises' => 'Learning Perl exercises',
);

# Takes an anon function and a list of arguments. Returns a closure
# which will call the anon function with those arguments prepended to
# the argument list.
#
# https://www.perlmonks.org/?node_id=109068
sub make_wanted {
	my ( $sub, @args ) = @_;
	return sub { $sub->( @args, @_ ); };
}

sub gzip_files {
	# Patterns are evaluated before file tests because it's less
	# expensive.
	return if $File::Find::name =~ /\.git/;
	return unless /\.(?:html|css|txt|xml|asc)\z/;

	my $src_toggle = shift // '';
	if ( $src_toggle eq 'no-src' ) {
		if ( $File::Find::name =~ /$src_dir/ ) {
			return
				unless $_ eq $src_page;
		}
	}

	return unless -f;

	unless ( eval { gzip $_ => "$_.gz" or die "gzip failed: $GzipError\n"; } ) {
		print STDERR "Couldn't compress file: $@" if $@;
	}
}

sub generate_website {
	my $clone_dir = tempdir( CLEANUP => 1 );
	system qw(git clone --), $repo_location, $clone_dir;

	my $ssg_pid =
		open3( undef, my $ssg_out, '>&STDERR', $bin_ssg,
			$clone_dir, $web_server_dir, $domain_without_schema,
			$domain_with_schema )
		or die "Could not open ssg: $!\n";

	waitpid $ssg_pid, 0;

	# NOTE: This MUST come after waitpid; otherwise, ssg won't generate
	# the website.
	close $ssg_out;

	my $rss_title = "Newsletter - $domain_without_schema";
	my $rss_file_path = catdir $web_server_dir, 'rss.xml';
	my $rssg_index_name = 'index.md';

	# NOTE: For whatever reason, rssg doesn't play nice with sending its
	# STDOUT to a file handle. It hangs indefinitely.
	my $rssg_pid =
		open3( undef, my $rssg_out, '>&STDERR', $bin_rssg,
			catfile( $clone_dir, $rssg_index_name ), $rss_title )
		or die "Could not open rssg: $!\n";

	open my $rss_feed_fh, '>', $rss_file_path;
	while (<$rssg_out>) { print $rss_feed_fh $_; }

	waitpid $rssg_pid, 0;

	# Does the order in which filehandles are closed matter here?
	close $rssg_out;
	close $rss_feed_fh;
}

sub update_sysadm {
	my $clone_dir = tempdir( CLEANUP => 1 );
	system qw(git clone --), $repo_location, $clone_dir;

	my $sysadm_dir = catdir &rootdir, 'etc', $sysadm_repo_name;

	# Clear out $sysadm_dir.
	my @files_to_delete;
	opendir( my $sysadm_dir_fh, $sysadm_dir );
	while ( my $file = readdir $sysadm_dir_fh ) {
		next if $file eq '.';
		next if $file eq '..';
		$file = catfile $sysadm_dir, $file;
		push @files_to_delete, $file;
	}
	closedir $sysadm_dir_fh;
	system qw(rm -rf --), @files_to_delete;

	# Move files from $clone_dir to $sysadm_dir.
	my @files_to_copy;
	opendir( my $clone_dir_fh, $clone_dir );
	while ( my $file = readdir $clone_dir_fh ) {
		next if $file eq '.';
		next if $file eq '..';
		next if $file eq '.git';
		$file = catfile $clone_dir, $file;
		push @files_to_copy, $file;
	}
	closedir $clone_dir_fh;
	system qw(mv -f --), @files_to_copy, $sysadm_dir;
}

sub update_ssg {
	my $clone_dir = tempdir( CLEANUP => 1 );
	system qw(git clone --), $repo_location, $clone_dir;

	my $clone_bin = catdir $clone_dir, qw(.local bin);
	my $clone_ssg = catdir $clone_bin, 'ssg6';
	my $clone_rssg = catdir $clone_bin, 'rssg';

	move $clone_ssg, $bin_ssg;
	move $clone_rssg, $bin_rssg;

	chmod 0700, $bin_ssg, $bin_rssg;
}

sub clone_and_stagit {
	my $stagit_git_dir = catdir $stagit_dir, '.git';
	system qw(git clone --bare --), $repo_location, $stagit_git_dir;

	chdir $stagit_git_dir;
	system qw(git update-server-info);
	chdir $stagit_dir;
	system qw(stagit --), $repo_location;
}

unless (
	eval {
		open my $repo_owner_fh, '>', catfile( $repo_location, 'owner' );
		say $repo_owner_fh $owner;
		close $repo_owner_fh;
	}
	)
{
	print STDERR "Couldn't write to $repo_location/owner $@" if $@;
}

unless (
	eval {
		open my $repo_description_fh, '>',
			catfile( $repo_location, 'description' );
		say $repo_description_fh $repo_descriptions{$repo_name_no_dot_git};
		close $repo_description_fh;
	}
	)
{
	print STDERR "Couldn't write to $repo_location/description: $@" if $@;
}

system qw(rm -rf --), $stagit_dir;
system qw(mkdir -p --), $stagit_dir;

if ( $repo_name_no_dot_git eq $website_repo_name ) {
	opendir( my $web_server_dir_fh, $web_server_dir );
	my @files_to_delete;
	while ( my $file = readdir $web_server_dir_fh ) {
		next if $file eq '.';
		next if $file eq '..';
		next if $file eq $src_dir;
		$file = catdir $web_server_dir, $file;
		push @files_to_delete, $file;
	}
	closedir $web_server_dir_fh;
	system qw(rm -rf --), @files_to_delete;

	generate_website;
	unlink catdir( $web_server_dir, '.files' );
	find make_wanted( \&gzip_files, 'no-src' ), $web_server_dir;
}
elsif ( $repo_name_no_dot_git eq $sysadm_repo_name ) {
	update_sysadm;
}
elsif ( $repo_name_no_dot_git eq $dotfiles_repo_name ) {
	update_ssg;
}

clone_and_stagit;

copy catfile( $stagit_dir, 'log.html' ), catfile( $stagit_dir, 'index.html' );
copy catfile( $web_server_dir, qw(stagit style.css) ),
	catfile( $stagit_dir, 'style.css' );

find make_wanted( \&gzip_files ), $stagit_dir;
