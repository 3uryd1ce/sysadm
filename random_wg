#!/usr/bin/env perl
# Copyright (c) 2022-2023 Ashlen <eurydice@riseup.net>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

# What this script does:
# Parses a random WireGuard configuration file, then brings up a wg(4) interface
# with appropriate parameters using ifconfig(8).
#
# Can optionally do other things:
# - Specify an rtable(4) for `wgrtable`.
# - Flush and add appropriate pf(4) rules in given anchors.
# - Adjust the MTU of the WireGuard interface.
# - "Dry run" to see what would happen.

# Background information:
#
# Protocol: https://www.wireguard.com/protocol/
#
# Relevant upstream man pages (details configuration file options as well):
# https://www.man7.org/linux/man-pages/man8/wg-quick.8.html
# https://www.man7.org/linux/man-pages/man8/wg.8.html

# TODO:
# - Write a proper man page.
#
# - Make this so that if there's failure, it won't leave networking in a partial
#   and potentially broken state. Sanity checks are performed so that commands
#   later down the line have a good chance of having valid syntax, but something
#   more robust like an exit routine should be added to restore the previous
#   working configuration just in case.
#
# - Plan around the use case where this program gets executed if a tunnel has
#   lost connectivity and a VPN reset is desired.
#
# - Address long lines.
#
# - Print the line where configuration parsing failed/errored out if that's the
#   case.

# UNLIKELY:
# - Decoupling this from OpenBSD and making it more system agnostic. Even if
#   this was a consideration, it wouldn't be a priority; it would require use of
#   commands other than ifconfig(8), pfctl(8), and rcctl(8). That means that the
#   process necessary to actually configure the network + firewall would have to
#   be made entirely modular. I'd rather have this work well against one system
#   than be broken on many that I don't test against.

use v5.32;
use strict;
use warnings;
use autodie qw(:all);

use File::Basename qw(fileparse);
use Getopt::Std;
use List::Util qw(sample);
use MIME::Base64 qw(decoded_base64_length);
use Scalar::Util qw(looks_like_number);

# External modules should be separated from modules included with Perl.
use Config::Std;
use IPC::System::Simple;
use Net::IP qw(ip_get_version ip_splitprefix);

my $program_name = fileparse $0;

sub usage {
	die <<EOF;
$program_name [-hnNv] [-c config]
EOF
}

# $ip can be an IPv4 or IPv6 address with or without prefix.
# $type is optional. If provided, can be '4' or '6'.
sub handle_prefix_ip {
	my $ip = shift or return;
	my $type = shift;
	my $prefix;

	# The substitution strips the prefix, otherwise ip_get_version errors.
	my $ip_type = ip_get_version( $ip =~ s|/ [0-9]+ \z||rx );
	$ip_type or die "Expected an IP address. Received: '$ip'\n";

	if ( defined $type ) {
		if ( ( $type != 4 ) and ( $type != 6 ) ) {
			die "Expected IP type of '4' or '6'. Received: '$type'\n";
		}
		$ip_type eq $type
			or die "'$ip_type' doesn't match given type ('$type')\n";
	}

	( $ip, $prefix ) = ip_splitprefix $ip
		or die "Unable to split prefix of '$ip'.\n";

	return ( $ip, $prefix );
}

our ( $opt_c, $opt_h, $opt_n, $opt_N, $opt_v );

getopts 'c:hnNv';
usage if $opt_h;

my $config_file = $opt_c // '/etc/random_wg.conf';
read_config $config_file => my %config or die "Parsing error: $!\n";

my $check_config_syntax = $opt_n // 0;
my $dry_run = $opt_N // 0;
my $verbose = $opt_v // $config{misc}{verbose} // 0;

my @conf_files = @{ $config{files}->{conf_files} };
@conf_files // die
	"$program_name needs config files to initialize WireGuard. See wg(8).\n";

# Set default configuration values, reading them into simple variables.
my $clearnet_interface = $config{networking}{clearnet_interface} // 'em0';
my $wg_interface = $config{networking}{wg_interface} // 'wg0';
my $adjust_mtu = $config{networking}{adjust_mtu} // 0;
my $mtu_size = $config{networking}{mtu_size} // 1412;
my $use_rtable = $config{networking}{use_rtable} // 0;
my $rtable_number = $config{networking}{rtable_number} // 1;
my $adjust_anchors = $config{firewall}{adjust_anchors} // 0;
my $dns_anchor_name = $config{firewall}{dns_anchor_name} // 'vpn_dns';
my $endpoint_anchor_name = $config{firewall}{endpoint_anchor_name}
	// 'vpn_endpoint';

# Clear unneeded variables out.
undef %config;
undef $config_file;
undef $opt_c;
undef $opt_h;
undef $opt_n;
undef $opt_N;
undef $opt_v;

$adjust_anchors =~ /\A [0-1] \z/x
	or die
	"adjust_anchors is a boolean. It must be either '1' or '0' (true or false).\n";

$adjust_mtu =~ /\A [0-1] \z/x
	or die
	"adjust_mtu is a boolean. It must be either '1' or '0' (true or false).\n";

$use_rtable =~ /\A [0-1] \z/x
	or die
	"use_rtable is a boolean. It must be either '1' or '0' (true or false).\n";

if ( ! looks_like_number($rtable_number)
	|| $rtable_number < 0
	|| $rtable_number > 255 )
{
	die "Provide an integer between 0-255 for rtable(4).\n";
}

# Numbers are taken from sys/net/if_wg.c:
# if (ifr->ifr_mtu <= 0 || ifr->ifr_mtu > 9000)
#     ret = EINVAL;
if ( ! looks_like_number($mtu_size)
	|| $mtu_size <= 0
	|| $mtu_size > 9000 )
{
	die "Provide an integer between 1-9000 for the MTU.\n";
}

$clearnet_interface =~ /\A [a-z]+ [0-9]+ \z/aaxx
	or die "The clearnet interface must match '/[a-z]+[0-9]+/'.\n";

$wg_interface =~ /\A wg[0-9]+ \z/aaxx
	or die "wg(4) must match '/wg[0-9]+/'.\n";

# TODO: perhaps print out the working configuration if -v is set.
exit if $check_config_syntax;

my $wg_file = sample 1, @conf_files;
$wg_file // die "$program_name needs a WireGuard configuration file.\n";
undef @conf_files;

my %wg_properties;

open my $wg_file_fh, '<', $wg_file;

# The format of the configuration file being parsed is based on INI.
while ( readline $wg_file_fh ) {
	chomp;

	if (/\A PrivateKey/aaxx) {
		my $private_key = ( split ' ' )[-1];

		# The private key should always be 44 bytes in length when encoded in
		# base64 and 32 bytes in length when decoded from base64. The same
		# applies for public keys as well.
		decoded_base64_length $private_key == 32
			or die "The given private key ($private_key) couldn't be base64 "
			. "decoded to a 32 byte string.\n";

		$wg_properties{private_key} = $private_key;
	}

	elsif (/\A Address/aaxx) {
		my $local_ip = ( split ' ' )[-1];
		my ( $local_ipv4, $local_ipv6 ) = split ',', $local_ip;

		($local_ipv4) = handle_prefix_ip $local_ipv4, 4;
		($local_ipv6) = handle_prefix_ip $local_ipv6, 6;

		$wg_properties{local_ipv4} = $local_ipv4;
		$wg_properties{local_ipv6} = $local_ipv6;
	}

	elsif (/\A PublicKey/aaxx) {
		my $peer_key = ( split ' ' )[-1];

		decoded_base64_length $peer_key == 32
			or die "The given peer key ($peer_key) couldn't be base64 "
			. "decoded to a 32 byte string.\n";

		$wg_properties{peer_key} = $peer_key;
	}

	elsif (/\A Endpoint/aaxx) {
		my $endpoint = ( split ' ' )[-1];
		my ( $endpoint_ip, $endpoint_port ) = split ':', $endpoint;

		($endpoint_ip) = handle_prefix_ip $endpoint_ip;

		# TODO: is this range perhaps too permissive/wide?
		unless ( looks_like_number $endpoint_port
			and $endpoint_port >= 1
			and $endpoint_port <= 65535 )
		{
			die "Expected: endpoint port - 1-5 digits, between 1-65535.\n"
				. "Received: $endpoint_port\n";
		}

		$wg_properties{endpoint_ip} = $endpoint_ip;
		$wg_properties{endpoint_port} = $endpoint_port;
	}

	elsif (/\A DNS/aaxx) {
		my $dns_ip = ( split ' ' )[-1];
		($dns_ip) = handle_prefix_ip $dns_ip;
		$wg_properties{dns_ip} = $dns_ip;
	}

	elsif (/\A AllowedIPs/aaxx) {
		my $allowed_ips = ( split ' ' )[-1];
		my ( $allowed_ipv4, $allowed_ipv6 ) = split ',', $allowed_ips;

		# Preserving the netmask is important (AllowedIPs consists of IPv(4|6)
		# ranges that specify what addresses the peer allows inbound traffic to
		# originate from, and what addresses the peer allows itself to send
		# outbound traffic to).
		my ( $allowed_ipv4_prefix, $allowed_ipv6_prefix );
		( $allowed_ipv4, $allowed_ipv4_prefix ) =
			handle_prefix_ip $allowed_ipv4, 4;
		( $allowed_ipv6, $allowed_ipv6_prefix ) =
			handle_prefix_ip $allowed_ipv6, 6;

		$allowed_ipv4 = $allowed_ipv4 . "/$allowed_ipv4_prefix";
		$allowed_ipv6 = $allowed_ipv6 . "/$allowed_ipv6_prefix";

		$wg_properties{allowed_ipv4} = $allowed_ipv4;
		$wg_properties{allowed_ipv6} = $allowed_ipv6;
	}
}

close $wg_file_fh;

if ($dry_run) {
	if ($verbose) {
		say "Would execute: `ifconfig $wg_interface destroy`";
		say "Would execute: `ifconfig $wg_interface create`";

		say "Would execute: `ifconfig $wg_interface wgkey "
			. "$wg_properties{private_key}`";

		say "Would execute: "
			. "`ifconfig $wg_interface wgpeer $wg_properties{peer_key} "
			. "wgendpoint $wg_properties{endpoint_ip} "
			. "$wg_properties{endpoint_port} "
			. "wgaip $wg_properties{allowed_ipv4}`";

		say "Would execute: "
			. "`ifconfig $wg_interface inet $wg_properties{local_ipv4}`";

		if ($use_rtable) {
			say "Would execute: "
				. "`ifconfig $wg_interface wgrtable $rtable_number`";
		}

		if ($adjust_mtu) {
			say "Would execute: `ifconfig $wg_interface mtu $mtu_size`";
		}

		say "Would execute: `ifconfig $wg_interface up`";

		say "Would execute: `route -qn add -inet default "
			. "-iface $wg_properties{local_ipv4}`";

		if ($adjust_anchors) {
			say "Would execute: `pfctl -a $dns_anchor_name -F all`";
			say "Would open pipe: `pfctl -a $dns_anchor_name -f -`";

			say "Would write to pipe: "
				. "`pass out quick on $wg_interface inet proto { tcp udp } "
				. "to $wg_properties{dns_ip} port domain`";

			say "Would close pipe.";

			say "Would execute: `pfctl -a $endpoint_anchor_name -F all`";
			say "Would open pipe: `pfctl -a $endpoint_anchor_name -f -`";

			say "Would write to pipe: "
				. "`pass out on $clearnet_interface inet proto udp "
				. "to $wg_properties{endpoint_ip} port "
				. "$wg_properties{endpoint_port}`";

			say "Would close pipe.";
		}
	}
}
else {
	eval {
		open my $old_STDERR, ">&", *STDERR;
		close STDERR;

		# Attempt to destroy the WireGuard interface so `ifconfig wgX create`
		# won't fail with "ifconfig: SIOCIFCREATE: File exists" later. If
		# destruction fails (wgX doesn't exist), ignore it and move on as it
		# isn't a problem.
		say "Executing: `ifconfig $wg_interface destroy`"
			if $verbose;
		eval { system 'ifconfig', $wg_interface, 'destroy'; };

		open STDERR, ">&", $old_STDERR;
		close $old_STDERR;
	};

	say "Executing: `ifconfig $wg_interface create`"
		if $verbose;
	system 'ifconfig', $wg_interface, 'create';

	say "Executing: "
		. "`ifconfig $wg_interface create $wg_properties{private_key}`"
		if $verbose;
	system 'ifconfig', $wg_interface, 'wgkey', $wg_properties{private_key};

	say "Executing: "
		. "`ifconfig $wg_interface wgpeer $wg_properties{peer_key} "
		. "wgendpoint $wg_properties{endpoint_ip} "
		. "$wg_properties{endpoint_port} "
		. "wgaip $wg_properties{allowed_ipv4}`"
		if $verbose;
	system 'ifconfig', $wg_interface, 'wgpeer',
		$wg_properties{peer_key},
		'wgendpoint', $wg_properties{endpoint_ip},
		$wg_properties{endpoint_port}, 'wgaip', $wg_properties{allowed_ipv4};

	say "Executing: "
		. "`ifconfig $wg_interface inet $wg_properties{local_ipv4}`"
		if $verbose;
	system 'ifconfig', $wg_interface, 'inet', $wg_properties{local_ipv4};

	# wgrtable can be relevant when the WireGuard interface uses the default
	# routing table and what would ordinarily be egress uses a non-default
	# routing table [see rdomain(4) and rtable(4)]. This setup can be useful as
	# a fail-safe mechanism so that the "actual" IP isn't leaked when the VPN
	# goes down (connectivity will be lost instead).
	if ($use_rtable) {
		say "Executing: `ifconfig $wg_interface wgrtable $rtable_number`"
			if $verbose;
		system 'ifconfig', $wg_interface, 'wgrtable', $rtable_number;
	}

	# The default MTU of 1420 is made with the assumption that egress uses an
	# MTU of 1500, but that assumption may not always be correct. Though it
	# often is, things like pppoe(4) can complicate things. It's important to
	# have the right MTU to avoid IP fragmentation because Path MTU Discovery
	# can't be relied on (erroneous blocking of ICMP for "security" by service
	# providers).
	#
	# Background information on the default MTU:
	# https://lists.zx2c4.com/pipermail/wireguard/2017-December/002201.html
	if ($adjust_mtu) {
		say "Executing: `ifconfig $wg_interface mtu $mtu_size`"
			if $verbose;
		system 'ifconfig', $wg_interface, 'mtu', $mtu_size;
	}

	say "Executing: `ifconfig $wg_interface up`"
		if $verbose;
	system 'ifconfig', $wg_interface, 'up';

	say "Executing: `route -qn add -inet default "
		. "-iface $wg_properties{local_ipv4}`"
		if $verbose;
	system qw(route -qn add -inet default -iface), $wg_properties{local_ipv4};

	if ($adjust_anchors) {
		say "Executing: `pfctl -a $dns_anchor_name -F all`"
			if $verbose;
		system qw(pfctl -a), $dns_anchor_name, qw(-F all);

		say "Opening pipe: `pfctl -a $dns_anchor_name -f -`"
			if $verbose;
		open my $pfctl_dns_fh, '|-', qw(pfctl -a), $dns_anchor_name, qw(-f -);

		# This pass rule uses `quick` because the anchor is placed right before
		# a rule in my pf.conf(5) that blocks connections to private addresses
		# (RFC1918 and friends). These are also known as "martian addresses" or
		# similar because they aren't (shouldn't be) publicly routable. Without
		# making use of `quick`, the provided IP address for DNS would be
		# blocked by the following rule as it's a private address.
		#
		# RFC1918: https://datatracker.ietf.org/doc/html/rfc1918
		#
		# TODO: Consider making this a configuration file option when the time
		# comes.
		say "Writing to pipe: `pass out quick on $wg_interface inet "
			. "proto { tcp udp } to $wg_properties{dns_ip} port domain`"
			if $verbose;
		print $pfctl_dns_fh
			"pass out quick on $wg_interface inet proto { tcp udp } "
			. "to $wg_properties{dns_ip} port domain";

		say "Closing pipe." if $verbose;
		close $pfctl_dns_fh;

		say "Executing: `pfctl -a $endpoint_anchor_name -F all`"
			if $verbose;
		system qw(pfctl -a), $endpoint_anchor_name, qw(-F all);

		say "Opening pipe: `pfctl -a $endpoint_anchor_name -f -`"
			if $verbose;
		open my $pfctl_endpoint_fh, '|-', qw(pfctl -a),
			$endpoint_anchor_name,
			qw(-f -);

		say "Writing to pipe: `pass out on $clearnet_interface inet "
			. "proto udp to $wg_properties{endpoint_ip} port "
			. "$wg_properties{endpoint_port}`"
			if $verbose;
		print $pfctl_endpoint_fh "pass out on $clearnet_interface "
			. "inet proto udp to $wg_properties{endpoint_ip} "
			. "port $wg_properties{endpoint_port}";

		say "Closing pipe." if $verbose;
		close $pfctl_endpoint_fh;

		# The rules are reloaded here so that a problem with queueing is
		# resolved (`systat -h queue` returns "DIOCGETQSTATS: Bad file
		# descriptor" because the interface changed and pf(4) had no chance to
		# catch up).
		eval { system qw(pfctl -nf), '/etc/pf.conf'; };
		if ($@) {
			warn "Parsing pf(4) rules failed: $@";
		}
		else {
			say "Executing `pfctl -f /etc/pf.conf`" if $verbose;
			system qw(pfctl -f), '/etc/pf.conf';
		}
	}
}
