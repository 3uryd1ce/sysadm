#!/bin/sh
# shellcheck disable=SC1090
# Copyright (c) 2020-2021 Ashlen <eurydice@riseup.net>

# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.

# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

set -e


err() {
  printf '%s\n' "$*" >&2
  exit 1
}


# grab the lines from a file formatted like hosts(5) that begin with
# 0.0.0.0 or 127.0.0.1 followed by one or more spaces or tabs, remove
# localhost definitions, remove carriage returns, ensure the delimiter
# is one tab for cut(1) with sed(1).
#
# $1 is a file or STDIN.
prepare_domains() {
  TAB="$(printf -- '\t')"
  readonly TAB

  grep -E -- "^(0\.0\.0\.0|127\.0\.0\.1)( |${TAB})+" "$1" \
    | grep -v -- 'localhost$'                             \
    | tr -d -- '\r'                                       \
    | sed -E -- "s/( +|${TAB}{2,})/${TAB}/"
}


# convert prepare_domains() output so either unwind(8) or unbound(8) can
# block those domains. sort domains and filter out duplicate entries.
#
# unwind's configuration syntax is simple--one domain per line.
#
# unbound's configuration syntax is in the form:
# local-zone: "example.com" always_refuse
#
# $1 is a file or STDIN.
format_domains() {
  case "${DNS}" in

    # there are two identical cut(1) invocations in the 'unwind' and
    # 'unbound' patterns, but refactoring and moving them up into
    # prepare_domains() means that cat(1) would need to be added to the
    # 'unwind' pattern to handle STDIN.
    'unwind')
      cut -f 2 -- "$1"

      # https://support.mozilla.org/en-US/kb/canary-domain-use-application-dnsnet
      echo 'use-application-dns.net'

      ;;

    'unbound')
      cut -f 2 -- "$1" | sed -- 's/.*/local-zone: "&" always_refuse/'

      echo 'local-zone: "use-application-dns.net" always_refuse'

      ;;

  esac | sort -u
}


[ "$(uname)" = 'OpenBSD' ] || err "${0##*/} only supports OpenBSD."
[ "$(id -u)" = 0 ] || err "Execute ${0##*/} with root privileges."


if [ "$(rcctl get unwind flags)" != 'NO' ]; then
  readonly DNS='unwind'
  readonly BLOCKLIST='/etc/blocklist.unwind'

elif [ "$(rcctl get unbound flags)" != 'NO' ]; then
  readonly DNS='unbound'
  readonly BLOCKLIST='/etc/blocklist.unbound'

else
  err "${0##*/} only supports unwind(8) and unbound(8)."

fi


# https://v.firebog.net/hosts/lists.php?type=tick
readonly BLOCKLIST_URLS='https://raw.githubusercontent.com/PolishFiltersTeam/KADhosts/master/KADhosts.txt
https://raw.githubusercontent.com/FadeMind/hosts.extras/master/add.Spam/hosts
https://v.firebog.net/hosts/static/w3kbl.txt
https://adaway.org/hosts.txt
https://v.firebog.net/hosts/AdguardDNS.txt
https://v.firebog.net/hosts/Admiral.txt
https://raw.githubusercontent.com/anudeepND/blacklist/master/adservers.txt
https://s3.amazonaws.com/lists.disconnect.me/simple_ad.txt
https://v.firebog.net/hosts/Easylist.txt
https://pgl.yoyo.org/adservers/serverlist.php?hostformat=hosts&showintro=0&mimetype=plaintext
https://raw.githubusercontent.com/FadeMind/hosts.extras/master/UncheckyAds/hosts
https://raw.githubusercontent.com/bigdargon/hostsVN/master/hosts
https://v.firebog.net/hosts/Easyprivacy.txt
https://v.firebog.net/hosts/Prigent-Ads.txt
https://raw.githubusercontent.com/FadeMind/hosts.extras/master/add.2o7Net/hosts
https://raw.githubusercontent.com/crazy-max/WindowsSpyBlocker/master/data/hosts/spy.txt
https://hostfiles.frogeye.fr/firstparty-trackers-hosts.txt
https://raw.githubusercontent.com/DandelionSprout/adfilt/master/Alternate%20versions%20Anti-Malware%20List/AntiMalwareHosts.txt
https://osint.digitalside.it/Threat-Intel/lists/latestdomains.txt
https://s3.amazonaws.com/lists.disconnect.me/simple_malvertising.txt
https://v.firebog.net/hosts/Prigent-Crypto.txt
https://bitbucket.org/ethanr/dns-blacklists/raw/8575c9f96e5b4a1308f2f12394abd86d0927a4a0/bad_lists/Mandiant_APT1_Report_Appendix_D.txt
https://phishing.army/download/phishing_army_blocklist_extended.txt
https://gitlab.com/quidsup/notrack-blocklists/raw/master/notrack-malware.txt
https://raw.githubusercontent.com/Spam404/lists/master/main-blacklist.txt
https://raw.githubusercontent.com/FadeMind/hosts.extras/master/add.Risk/hosts
https://urlhaus.abuse.ch/downloads/hostfile/
https://zerodot1.gitlab.io/CoinBlockerLists/hosts_browser'


TMP_BLOCKLIST="$(mktemp)"
readonly TMP_BLOCKLIST


printf '%s\n' "${BLOCKLIST_URLS}"    \
  | xargs -- ftp -o - -- 2>/dev/null \
  | prepare_domains -                \
  | format_domains -                 \
  > "${TMP_BLOCKLIST}"               \
  || err 'Unable to create blocklist.'


# if no blocklist is present, just create a blank template file so mv(1)
# is guaranteed to have something to move and ${BLOCKLIST}.bak is
# guaranteed to exist.
[ -f "${BLOCKLIST}" ] || :>"${BLOCKLIST}"
chmod -- 0444 "${BLOCKLIST}"
mv -- "${BLOCKLIST}" "${BLOCKLIST}.bak"

install -m 0444 -- "${TMP_BLOCKLIST}" "${BLOCKLIST}" \
  || err "Unable to install(1) ${TMP_BLOCKLIST} to ${BLOCKLIST}"


case "${DNS}" in
  'unwind')  unwind -n         && rcctl restart unwind  ;;
  'unbound') unbound-checkconf && rcctl restart unbound ;;
esac >/dev/null 2>&1 ||

  {
    # ${BLOCKLIST}.bak should always be a working file with appropriate
    # permissions, so it is safe to move ${BLOCKLIST}.bak to
    # ${BLOCKLIST} without further checks.
    mv -- "${BLOCKLIST}.bak" "${BLOCKLIST}"

    # exits immediately without removing ${TMP_BLOCKLIST} and printing the
    # file in the error message so it can be inspected.
    err "restart_dns() failed, which probably means ${DNS}(8) didn't like ${TMP_BLOCKLIST}.

For now, either the previous working blocklist or a blank blocklist was
instated at ${BLOCKLIST} with appropriate permissions."
  }

# if the case statement above fails, the script exits before the removal
# so the temporary blocklist is kept.
rm -- "${TMP_BLOCKLIST}"
