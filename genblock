#!/usr/bin/env perl
# Copyright (c) 2022-2023 Ashlen <eurydice@riseup.net>

# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.

# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use v5.36;
use autodie;
use strict;
use warnings;

use File::Basename qw(fileparse);
use Getopt::Std;
use List::Util qw(first);

my $program_name = fileparse $0;

sub usage {
	die <<"EOT";
$program_name extracts unique domains. Useful for generating blocklists.

usage: $program_name [-h] [-t type] [file (optional)] ...

-h: help.

-t: type of format, 'plain' by default.
    'plain' extracts one domain per line and does no other formatting.

    'unbound' formats the domain as 'local-zone: \"[domain]\" always_refuse'

    'rpz' formats the domain as '[domain] CNAME .', and then copies that to a
    wildcard entry. It also reduces domains to avoid unnecessary duplication.

$program_name can read from STDIN, or one or more files.
EOT
}

sub is_domain {
	my $potential_domain = shift or return 0;

	if (
		$potential_domain =~ /
	# For more details, see:
	# RFC1123 section 2-1
	# RFC1034 section 3-1
	# RFC2181 section 11

	# This "main" group MUST match one or more times
	#
	# Its role is to match the leaves in the domain before the top-level domain,
	# and to do so it encapsulates the optional "hyphen" group because a domain
	# MAY have hyphens, but we don't know for sure whether it will
	#
	# It also includes a "lookahead" to ensure that each leaf is no longer than
	# 63 characters---this is a zero-width assertion that checks RFC compliance
	# by looking to see if there are 1-63 letters, digits, hyphens, and
	# underscores until the next dot
	#
	# If the lookahead succeeds, proceed with matching one or more alphanumeric
	# characters to start
	\b
	(
	(?= [a-z 0-9 -_]{1,63} \.)
	[a-z 0-9]+

	# This "hyphen" group MAY match zero or more times
	#
	# Its role is to capture hyphens in the middle of a leaf, like "abc-xyz" for
	# instance
	#
	# Inside the optional "hyphen" group, match one or more hyphens or
	# underscores, followed by one or more alphanumeric characters
	(
	[-_]+
	[a-z 0-9]+
	)*

	# The "main" noncapturing group ends with a period to mark the end of a
	# leaf
	#
	# The "main" noncapturing group MUST match one or more times as said before,
	# as this accounts for all of the leaves before the top-level domain
	\.
	)+

	# This begins the "top-level domain" section
	#
	# It's relatively simple, it MUST be one of two things:
	#
	# A punycode prefixed top-level domain
	# OR
	# A regular top-level domain
	(

	# The top-level domain MAY be a punycode prefixed top-level domain, starting
	# with 'xn--' and matching one or more alphanumeric characters afterward
	(
	xn--
	[a-z 0-9]{2,59}
	)

	| # OR

	# If the top-level domain wasn't the punycode prefixed variant, then it MUST
	# be a regular top-level domain
	#
	# Has at least two letters
	[a-z]{2,63}

	# The top-level domain is the end, so conclude the regular expression by
	# closing the "top-level domain" group followed by a word boundary
	)
	\b
	/paaxxn
		)
	{
		return ${^MATCH};
	}
	return 0;
}

# Given a hash reference, we "reduce" fully-qualified domains by
# starting with their root domain.
#
# If the root domain is a key in the hash, delete the fully-qualified
# domain (a wildcard will match it).
#
# Otherwise, progressively add subdomains back in, moving right to left,
# until we either discover a matching key or reach the end.
#
# Example:
# advertising.bad-actor.com
# bad-actor.com
#
# *.bad-actor.com will match advertising.bad-actor.com as well.
# Therefore, we can delete advertising.bad-actor.com from the hash.
sub reduce_domains {
	my $hashref = shift or return;
	my $redundant_domains_hashref;

	while ( my ( $domain, undef ) = each %$hashref ) {
		my @domain_leaves = reverse( split /\./, $domain );
		my $index = 1;

		while ( ( $index + 1 ) != scalar(@domain_leaves) ) {
			my $leaf =
				join( '.', reverse( @domain_leaves[ 0 .. $index ] ) );

			if ( defined $hashref->{$leaf} ) {
				delete $hashref->{$domain};
				$redundant_domains_hashref->{$domain} = $leaf;
				last;
			}

			$index++;
		}
	}
	wantarray
		? return keys %$redundant_domains_hashref
		: return $redundant_domains_hashref;
}

sub unique_domains {
	my $hashref = shift or return 0;
	my $number_of_domains_added = 0;

PROCESS_LINE: while ( <<>> ) {
		## Don't process commented or blank lines.
		next if /\A \s*? \#/aaxx;
		next if /\A \s* \z/aaxx;

		# Get rid of these common leading IP addresses in hosts(5)
		# formatted blocklists.
		#
		# Types of entries that this addresses:
		# 0.0.0.0alfa-bitcoin.com
		s/\A \s*? 127\.0\.0\.1 \s*?//aaxx;
		s/\A \s*? 0\.0\.0\.0 \s*?//aaxx;

		# Lines with these IP addresses at the tail end of a word
		# (likely caused by maintainer typos) can't be trusted. Messing
		# with them is likely to mangle the line and give a bogus
		# result; accepting them is also likely to give a bogus result.
		#
		# Here are two examples of lines that match:
		# zy16eoat1w.com0.0.0.0 102.112.2o7.net
		# vungle.com0.0.0.0adminer.com
		next if /\B 127\.0\.0\.1/aaxx;
		next if /\B 0\.0\.0\.0/aaxx;

		# Lowercase vs uppercase doesn't matter for DNS.
		$_ = lc $_;
		chomp;

		my $domain = do {
			is_domain $_ or next PROCESS_LINE;
		};

		$hashref->{$domain}++;
		$number_of_domains_added++;
	}
	return $number_of_domains_added;
}

our $opt_h;
our $opt_t = 'plain';

getopts 'ht:';
usage if defined($opt_h);

my @formats = qw(plain unbound rpz);
first { $opt_t eq $_ } @formats or die "$opt_t is not a valid type.\n";

my %domain_appearances;

&unique_domains( \%domain_appearances )
	or die "Unable to extract any domains from input.\n";

if ( $opt_t eq 'plain' ) {
	print map { "$_\n" } sort keys %domain_appearances;
}
elsif ( $opt_t eq 'unbound' ) {
	print map { "local-zone: \"$_\" always_refuse\n" }
		sort keys %domain_appearances;
}
elsif ( $opt_t eq 'rpz' ) {
	&reduce_domains( \%domain_appearances );

	#<<<
	print map {
		"$_ CNAME .\n"
		. "*.$_ CNAME .\n"
	} sort keys %domain_appearances;
	#>>>
}
