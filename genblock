#!/usr/bin/env perl
# Copyright (c) 2022 Ashlen <eurydice@riseup.net>

# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.

# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

# TODO: reduce number of domains in rpz format (the wildcards get out of control
# given that many hosts files are an enumeration of many subdomains---this could
# be better solved by identifying redundant patterns and pruning them from the
# final blocklist)

use v5.32;
use autodie;
use strict;
use warnings;

use Scalar::Util qw(looks_like_number);
use experimental qw(smartmatch);

# Extract file name.
use File::Basename qw(fileparse);

# Parse command line options.
use Getopt::Std;

our ( $opt_h, $opt_O );
our $opt_t = 'plain';

my @formats = qw(plain unbound rpz);

my $program_name = fileparse $0;

sub usage {
	die <<"EOT";
$program_name extracts unique domains. Useful for generating blocklists.

usage: $program_name [-h] [-t type] [file (optional)] ...

-h: help.

-O: origin FQDN for \$ORIGIN. Example: 'sinkhole.home.arpa'. Only valid when
    type is 'rpz'.

-t: type of format, 'plain' by default.
    'plain' extracts one domain per line and does no other formatting.
    'unbound' formats the domain as 'local-zone: \"[domain]\" always_refuse'
    'rpz' formats the domain as '\$ORIGIN.[domain] CNAME .'

$program_name reads from STDIN or a given file.
EOT
}

sub is_domain {
	my $potential_domain = shift or die "is_domain needs a potential domain.\n";

	if (
		$potential_domain =~ /
	\b # word boundary

	### BEGIN DOMAINS BEFORE TOP-LEVEL DOMAIN ###
	(?: # begin noncapturing group
	[a-z 0-9]+ # one or more lowercase or number characters

	### BEGIN OPTIONAL GROUP - HYPHENS AND UNDERSCORES
	(?: # begin noncapturing group
	[-_]+ # one or more hyphens or underscores
	[a-z 0-9]+ # one or more lowercase or number characters
	)* # end of noncapturing group, matches zero or more times
	### END OPTIONAL GROUP - HYPHENS AND UNDERSCORES

	\. # period
	)+ # end noncapturing group
	### END DOMAINS BEFORE TOP-LEVEL DOMAIN ###

	### TOP-LEVEL DOMAIN ###
	(?: # begin noncapturing group

	(?: # begin noncapturing group
	xn-- # punycode prefix
	[a-z 0-9]+ # one or more lowercase or number characters
	) # end the punycode noncapturing group

	| # OR

	[a-z]{2,} # two or more lowercase characters
	) # end noncapturing group
	### END TOP-LEVEL DOMAIN ###

	\b # word boundary
	/paaxx
		)
	{
		return ${^MATCH};
	}
	return 0;
}

sub is_fqdn {
	my $potential_domain = shift or die "is_domain needs a potential domain.\n";

	if (
		$potential_domain =~ /
	\b # word boundary

	### BEGIN DOMAINS BEFORE TOP-LEVEL DOMAIN ###
	(?: # begin noncapturing group
	[a-z 0-9]+ # one or more lowercase or number characters

	### BEGIN OPTIONAL GROUP - HYPHENS AND UNDERSCORES
	(?: # begin noncapturing group
	[-_]+ # one or more hyphens or underscores
	[a-z 0-9]+ # one or more lowercase or number characters
	)* # end of noncapturing group, matches zero or more times
	### END OPTIONAL GROUP - HYPHENS AND UNDERSCORES

	\. # period
	){2,} # end noncapturing group
	### END DOMAINS BEFORE TOP-LEVEL DOMAIN ###

	### TOP-LEVEL DOMAIN ###
	(?: # begin noncapturing group

	(?: # begin noncapturing group
	xn-- # punycode prefix
	[a-z 0-9]+ # one or more lowercase or number characters
	) # end the punycode noncapturing group

	| # OR

	[a-z]{2,} # two or more lowercase characters
	) # end noncapturing group
	### END TOP-LEVEL DOMAIN ###

	\b # word boundary
	/paaxx
		)
	{
		return ${^MATCH};
	}
	return 0;
}

sub reduce_domains {
	my $domain = shift or die "reduce_domain needs a domain.\n";
	my $hashref = shift or die "reduce_domain needs a hashref.\n";

	is_domain $domain or return 0;

	my @domain_chars = split( '', $domain );
	my @reduced_domain_chars;

	while ( scalar @domain_chars > 0 ) {
		push @reduced_domain_chars, pop @domain_chars;

		if ( scalar @domain_chars == 0 ) {
			return $domain;
		}
		elsif ( $domain_chars[-1] eq '.' ) {
			my $leaf = join( '', reverse @reduced_domain_chars );
			next unless is_fqdn $leaf; # FQDN

			if ( defined $hashref->{$leaf} ) {
				return $leaf;
			}
			elsif ( my @unreduced_domains = grep { /$leaf\z/ } keys %$hashref )
			{
				return $leaf, @unreduced_domains;
			}
		}
	}
}

sub unique_domains {
	my $hashref = shift or die "unique_domains needs a hash reference.\n";
	my $should_reduce_domains = shift or 0;

	while ( <<>> ) {
		## Don't process commented or blank lines.
		next if /\A \s*? \#/aaxx;
		next if /\A \s* \z/aaxx;

		# Get rid of these common leading IP addresses in hosts(5)
		# formatted blocklists.
		s/\A \s*? 127\.0\.0\.1 \s*?//aaxx;
		s/\A \s*? 0\.0\.0\.0 \s*?//aaxx;

		# Lines with these IP addresses at the tail end of a word
		# (likely caused by maintainer typos) can't be trusted. Messing
		# with them is likely to mangle the line and give a bogus
		# result; accepting them is also likely to give a bogus result.
		#
		# Here are two examples of lines that match:
		# zy16eoat1w.com0.0.0.0 102.112.2o7.net
		# vungle.com0.0.0.0adminer.com
		next if /\B 127\.0\.0\.1/aaxx;
		next if /\B 0\.0\.0\.0/aaxx;

		# Lowercase vs uppercase doesn't matter for DNS.
		$_ = lc $_;
		chomp;

		if ( my $domain = is_domain $_ ) {
			if ($should_reduce_domains) {
				my ( $reduced_domain, @unreduced_domains ) = reduce_domains $_,
					$hashref;

				while ( my $unreduced_domain = shift @unreduced_domains ) {
					say "Deleting $unreduced_domain";
					delete $hashref->{$unreduced_domain};
				}
				$domain = $reduced_domain;
			}
		$hashref->{$domain}++;
		}
	}
	return ( keys %$hashref );
}

getopts 'hO:t:';
usage if defined($opt_h);

$opt_t ~~ @formats or die "$opt_t is not a valid type.\n";

my %domain_appearances;

if ( $opt_t eq 'plain' ) {
	print map { $_ . "\n" } sort &unique_domains( \%domain_appearances );
}
elsif ( $opt_t eq 'unbound' ) {
	print map { "local-zone: \"$_\" always_refuse" . "\n" }
		sort &unique_domains( \%domain_appearances );
}
elsif ( $opt_t eq 'rpz' ) {
	$opt_O // die "$program_name expects a domain name for \$ORIGIN.\n";

	is_domain $opt_O
		or die "$program_name expects a domain name for \$ORIGIN.\n";

	# This needs to be at the top of the file.
	say "\$ORIGIN $opt_O.";

	#print map { "$_.$opt_O. CNAME ." . "\n" } sort &unique_domains(\%domain_appearances);

	# This is commented out for now, because wildcards need to be optimized
	# first before it is used (without that optimization, it doubles the
	# blocklist size which results in more loss than gain).
	#<<<
	print map {
		"$_.$opt_O CNAME .\n"
		. "*.$_.$opt_O CNAME .\n"
	} sort &unique_domains( \%domain_appearances, 1 );
	#>>>
}
