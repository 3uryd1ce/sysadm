#!/usr/bin/env perl
# Copyright (c) 2022 Ashlen <eurydice@riseup.net>

# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.

# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

# TODO: reduce number of domains in rpz format (the wildcards get out of control
# given that many hosts files are an enumeration of many subdomains---this could
# be better solved by identifying redundant patterns and pruning them from the
# final blocklist)

use v5.32;
use autodie;
use strict;
use warnings;

use experimental qw(smartmatch);

# Extract file name.
use File::Basename qw(fileparse);

# Parse command line options.
use Getopt::Std;

our ( $opt_h, $opt_O );
our $opt_t = 'plain';

my @formats = qw(plain unbound rpz);

my $program_name = fileparse $0;

sub usage {
	die <<"EOT";
$program_name extracts unique domains. Useful for generating blocklists.

usage: $program_name [-h] [-t type] [file (optional)] ...

-h: help.

-O: origin FQDN for \$ORIGIN. Example: 'sinkhole.home.arpa'. Only valid when
    type is 'rpz'.

-t: type of format, 'plain' by default.
    'plain' extracts one domain per line and does no other formatting.

    'unbound' formats the domain as 'local-zone: \"[domain]\" always_refuse'

    'rpz' formats the domain as '[domain] CNAME .', and then copies that to a
    wildcard entry. It also reduces domains to avoid unnecessary duplication.

$program_name reads from STDIN or a given file.
EOT
}

sub is_domain {
	my $potential_domain = shift or return 0;

	if (
		$potential_domain =~ /
	\b # word boundary

	### BEGIN DOMAINS BEFORE TOP-LEVEL DOMAIN ###
	(?: # begin noncapturing group
	[a-z 0-9]+ # one or more lowercase or number characters

	### BEGIN OPTIONAL GROUP - HYPHENS AND UNDERSCORES
	(?: # begin noncapturing group
	[-_]+ # one or more hyphens or underscores
	[a-z 0-9]+ # one or more lowercase or number characters
	)* # end of noncapturing group, matches zero or more times
	### END OPTIONAL GROUP - HYPHENS AND UNDERSCORES

	\. # period
	)+ # end noncapturing group
	### END DOMAINS BEFORE TOP-LEVEL DOMAIN ###

	### TOP-LEVEL DOMAIN ###
	(?: # begin noncapturing group

	(?: # begin noncapturing group
	xn-- # punycode prefix
	[a-z 0-9]+ # one or more lowercase or number characters
	) # end the punycode noncapturing group

	| # OR

	[a-z]{2,} # two or more lowercase characters
	) # end noncapturing group
	### END TOP-LEVEL DOMAIN ###

	\b # word boundary
	/paaxx
		)
	{
		return ${^MATCH};
	}
	return 0;
}

sub reduce_domains {
	my $hashref = shift or return 0;

DOMAIN: while ( my ( $domain, undef ) = each %$hashref ) {
		my @domain_chars = split( '', $domain );
		my @reduced_domain_chars;

		while ( scalar @reduced_domain_chars < length $domain ) {
			push @reduced_domain_chars, pop @domain_chars;
			last if scalar @domain_chars == 0;

			if ( $domain_chars[-1] eq '.' ) {
				my $leaf = join( '', reverse @reduced_domain_chars );

				if ( defined $hashref->{$leaf} ) {
					delete $hashref->{$domain};
					next DOMAIN;
				}
			}
		}
	}
}

sub unique_domains {
	my $hashref = shift or die "unique_domains needs a hash reference.\n";

PROCESS_LINE: while ( <<>> ) {
		## Don't process commented or blank lines.
		next if /\A \s*? \#/aaxx;
		next if /\A \s* \z/aaxx;

		# Lines with these IP addresses at the tail end of a word
		# (likely caused by maintainer typos) can't be trusted. Messing
		# with them is likely to mangle the line and give a bogus
		# result; accepting them is also likely to give a bogus result.
		#
		# Here are two examples of lines that match:
		# zy16eoat1w.com0.0.0.0 102.112.2o7.net
		# vungle.com0.0.0.0adminer.com
		next if /\B 127\.0\.0\.1/aaxx;
		next if /\B 0\.0\.0\.0/aaxx;

		# Lowercase vs uppercase doesn't matter for DNS.
		$_ = lc $_;
		chomp;

		my $domain = do {
			is_domain $_ or next PROCESS_LINE;
		};

		$hashref->{$domain}++;
	}
	return ( keys %$hashref );
}

getopts 'hO:t:';
usage if defined($opt_h);

$opt_t ~~ @formats or die "$opt_t is not a valid type.\n";

my %domain_appearances;

if ( $opt_t eq 'plain' ) {
	print map { $_ . "\n" } sort &unique_domains( \%domain_appearances );
}
elsif ( $opt_t eq 'unbound' ) {
	print map { "local-zone: \"$_\" always_refuse" . "\n" }
		sort &unique_domains( \%domain_appearances );
}
elsif ( $opt_t eq 'rpz' ) {
	$opt_O // die "$program_name expects a domain name for \$ORIGIN.\n";

	is_domain $opt_O
		or die "$program_name expects a domain name for \$ORIGIN.\n";

	# Executed for their side-effects only (populating and reducing a hash).
	&unique_domains( \%domain_appearances );
	&reduce_domains( \%domain_appearances );

	# This needs to be at the top of the file.
	say "\$ORIGIN $opt_O.";

	# Without wildcards.
	# TODO: implement option to toggle wildcards.
	#print map { "$_.$opt_O. CNAME ." . "\n" } sort &unique_domains(\%domain_appearances);

	#<<<
	print map {
		"$_ CNAME .\n"
		. "*.$_ CNAME .\n"
	} sort keys %domain_appearances;
	#>>>
}
